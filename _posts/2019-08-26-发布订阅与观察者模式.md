---
layout: post
title:  订阅发布模式与观察者模式的区别
date:   2019-08-24 19:00:00 +0800
categories: 开发者
tag: 开发者
---

* content
{:toc}

### 1、观察者模式

观察者模式定义了对象间的一种**一对多的依赖关系**，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。

观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和目标（被观察者）之间的通讯。

观察者模式我们可能比较熟悉的场景就是响应式数据，如 Vue 的响应式：

```js
/**
 * 观察监听一个对象的变化
 * @param {Object} subject 观察的目标
 * @param {Function} callback 目标变化触发的回调
 */
function observer(subject, callback) {
  Object.defineProperty(subject, 'description', {
    get() {
      return this.data.description
    },
    set(val) {
      this.data.description = val
      // 目标主动通知观察者
      callback && callback(val)
    },
  })
}
```

### 2.订阅发布模式

其实24种基本的设计模式中并没有发布订阅模式，它只是观察者模式的一个别称。它的概念和观察者模式非常类似。

但是经过时间的沉淀，似乎他已经强大了起来，已经独立于观察者模式，成为另外一种不同的设计模式。

在现在的发布订阅模式中，称为发布者的消息发送者不会将消息直接发送给订阅者，这意味着发布者和订阅者不知道彼此的存在。在发布者和订阅者之间存在第三个组件，称为调度中心或事件通道，它维持着发布者和订阅者之间的联系，过滤所有发布者传入的消息并相应地分发它们给订阅者。

```js
class Event {
  constructor() {
    // 所有 eventType 监听器回调函数
    this.listeners = {}
  }
  /**
   * 订阅事件
   * @param {String} eventType 事件类型
   * @param {Function} listener 订阅后发布动作触发的回调函数，参数为发布的数据
   */
  on(eventType, listener) {
    if (!this.listeners[eventType]) {
      this.listeners[eventType] = []
    }
    this.listeners[eventType].push(listener)
  }
  /**
   * 发布事件
   * @param {String} eventType 事件类型
   * @param {Any} data 发布的内容
   */
  emit(eventType, data) {
    const callbacks = this.listeners[eventType]
    if (callbacks) {
      callbacks.forEach((c) => {
        c(data)
      })
    }
  }
}

const event = new Event()
event.on('open', (data) => {
  console.log(data)
})
event.emit('open', { open: true })
````

### 3.两种模式的区别

发布订阅模式相比观察者模式多了个事件通道，事件通道作为调度中心，管理事件的订阅和发布工作，彻底隔绝了订阅者和发布者的依赖关系。即订阅者在订阅事件的时候，只关注事件本身，而不关心谁会发布这个事件；发布者在发布事件的时候，只关注事件本身，而不关心谁订阅了这个事件。

观察者模式有两个重要的角色，即目标和观察者。在目标和观察者之间是没有事件通道的。一方面，观察者要想订阅目标事件，由于没有事件通道，因此必须将自己添加到目标(Subject) 中进行管理；另一方面，目标在触发事件的时候，也无法将通知操作(notify) 委托给事件通道，因此只能亲自去通知所有的观察者。
