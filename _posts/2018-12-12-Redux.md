---
layout: post
title:  Redux
date:   2018-12-12 19:58:00 +0800
categories: React
tag: React
---

* content
{:toc}

Redux 能让 Javascript 的状态管理变得更加可预期，Redux 让你以一种新方式思考开发应用，这个方式是：状态从一个初始状态开始，被一系列动作序列改变，这种新方式是通往复杂 Web 应用的捷径。

Redux 是对 Flux 的演进和改变，它们两者也有类似点： Redux 虽然可以使得应用状态改变能更加可预期，但是如果你要改变状态，你还是得启动激活一个动作 Action，没有其他办法直接改变状态，因为含有状态的组件只有一个 `getter` 方法，没有 `setter` 方法用来改变设置状态。

Redux 与 Flux 的主要区别是：

* 在 Redux 中没有 dispatcher，你直接监听者在 Action 动作中，当每次 Action 被激活需要 dispatch 时，使用一个函数称为 reducer 来返回新的应用状态。
* Redux 保留有你所有应用在一个地方，这样避免到处是可变状态，降低副作用。
* 应用状态是不可变的

### 1. Redux 的三大原则

1. 单一数据源 -- 整个应用的 `state` 被储存在一棵 `object tree` 中，并且这个 `object tree` 只存在于唯一一个 `store` 中。至于担心数据对象过于庞大的问题，Redux 提供的工具函数 `combineReducers` 可以化解。
2. 状态(State)是只读的 -- 唯一改变 `state` 的方法就是触发 `action`，`action` 是一个用于描述已发生事件的普通对象。
3. 状态(State)修改均有纯函数完成 -- 通过定义 `reducer` 来修改状态，而每一个 `reducer` 都是纯函数。

### 2. Redux 核心 API

**createStore(reducer, [preloadedState], enhancer)**：

1. reducer (Function): 接收两个参数，分别是当前的 state 树和要处理的 action，返回新的 state 树。
2. [preloadedState] (any): 初始时的 state。 在同构应用中，你可以决定是否把服务端传来的 state 水合（hydrate）后传给它，或者从之前保存的用户会话中恢复一个传给它。如果你使用 combineReducers 创建 reducer，它必须是一个普通对象，与传入的 keys 保持同样的结构。否则，你可以自由传入任何 reducer 可理解的内容。
3. enhancer (Function): Store enhancer 是一个组合 store creator 的高阶函数，返回一个新的强化过的 store creator。这与 middleware 相似，它也允许你通过复合函数改变 store 接口。

`createStore()` 返回一个 `Store` 对象，它包含 4 个方法：

* `getState()`: 返回 store 中的当前状态。
* `dispatch(action)`: 分发 action。这是触发 state 变化的惟一途径。
* `subscribe(listener)`: 添加一个变化监听器，在 store 发生变化时被调用。
* `replaceReducer(nextReducer)`: 替换 store 当前用来计算 state 的 reducer，一般只会在开发模式中调用该方法。

### 3. Action、Reducer、Store

Redux 出奇简单，它使用一个函数 `reducer`，只需要两个参数：一个动作 `action` 和下一个状态。`reducer` 函数能够访问当前状态，将动作应用到状态，返回下一个符合业务的状态，这是一种状态模式实现。

Reducer 并不存储状态，只传递状态，返回状态，这使得它看上去也像动作 Action。

#### 3.1 Action

`Action` 是把数据从应用传到 `store` 的有效载荷。它是 `store` 数据的唯一来源。一般来说你会通过 `store.dispatch()` 将 `action` 传到 `store`。

```js
<!-- 定义 Action  -->
const ADD_DATA = "ADD_DATA";
```

Action 本质上是 JavaScript 普通对象。我们约定，`action` 内必须使用一个字符串类型的 `type` 字段来表示将要执行的动作。多数情况下，`type` 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 `action`。

参照 [Flux 标准 Action](https://github.com/redux-utilities/flux-standard-action) 获取关于如何构造 `action` 的建议。

**Action 创建函数** 就是生成 action 的方法。这样做将使 action 创建函数更容易被移植和测试。

```js
function addTodo(text) {
  return { type: ADD_TODO, text }
}
```

#### 3.2 Reducer

Reducers 指定了应用状态的变化如何响应 `actions` 并发送到 `store` 的。`reducer` 就是一个**纯函数**，接收旧的 `state` 和 `action`，返回新的 `state`。

开发复杂的应用时，不可避免会有一些数据相互引用。建议你尽可能地把 `state` 范式化，不存在嵌套。把所有数据放到一个对象里，每个数据以 ID 为主键，不同实体或列表间通过 ID 相互引用数据。把应用的 `state` 想像成数据库。这种方法在 [normalizr](https://github.com/paularmstrong/normalizr) 文档里有详细阐述。

```js
const initialState = {
  index: 0
};
function todoApp(state = initialState, action) {
  switch (action.type) {
    case 'SET_VISIBILITY_FILTER':
      return Object.assign({}, state, {
        visibilityFilter: action.filter
      })
    case 'ADD_TODO':
      return Object.assign({}, state, {
        todos: [
          ...state.todos,
          {
            text: action.text,
            completed: false
          }
        ]
      })
    default:
      return state
  }
}
```

* **拆分 Reducer:**

Redux 提供了 `combineReducers()` 工具类来做这件事情。

```js
import { combineReducers } from 'redux'

const todoApp = combineReducers({
  visibilityFilter,
  todos
})

export default todoApp
```

```js
function todos(state = [], action) {
  switch (action.type) {
    case ADD_TODO:
      return [
        ...state,
        {
          text: action.text,
          completed: false
        }
      ]
    case TOGGLE_TODO:
      return state.map((todo, index) => {
        if (index === action.index) {
          return Object.assign({}, todo, {
            completed: !todo.completed
          })
        }
        return todo
      })
    default:
      return state
  }
}

function visibilityFilter(state = SHOW_ALL, action) {
  switch (action.type) {
    case SET_VISIBILITY_FILTER:
      return action.filter
    default:
      return state
  }
}
```

相当于：

```js
function todoApp(state = {}, action) {
  return {
    visibilityFilter: visibilityFilter(state.visibilityFilter, action),
    todos: todos(state.todos, action)
  }
}
```

注意每个 `reducer` 只负责管理全局 `state` 中它负责的一部分。每个 `reducer` 的 `state` 参数都不同，分别对应它管理的那部分 `state` 数据。

**注意:**

1. 不要修改 `state`。
2. 在 `default` 情况下返回旧的 `state`。遇到未知的 `action` 时，一定要返回旧的 `state`。

#### 3.3 Store

Redux 应用只有一个单一的 `store`。其有以下职责：

* 维持应用的 `state`；
* 提供 `getState()` 方法获取 `state`；
* 提供 `dispatch(action)` 方法更新 `state`；
* 通过 `subscribe(listener)` 注册监听器;

```js
import { createStore } from 'redux'
import todoApp from './reducers'
let store = createStore(todoApp)
```

### 4. 与 React 绑定使用

Redux 和 React 之间没有关系。要让 Redux 在 React 中发挥作用，还需要 `react-redux`。

```js
npm install --save redux react-redux
```

一个简单的例子：

```jsx
import React from 'react'
import ReactDOM from 'react-dom'
import { createStore } from 'redux'
import Counter from './components/Counter'
import counter from './reducers'

const store = createStore(counter)
const rootEl = document.getElementById('root')

const render = () => ReactDOM.render(
  <Counter
    value={store.getState()}
    onIncrement={() => store.dispatch({ type: 'INCREMENT' })}
    onDecrement={() => store.dispatch({ type: 'DECREMENT' })}
  />,
  rootEl
)

render()
store.subscribe(render)
```

```js
<!-- reducer -->
export default (state = 0, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return state + 1
    case 'DECREMENT':
      return state - 1
    default:
      return state
  }
}
```

```jsx
import React, { Component } from 'react'
import PropTypes from 'prop-types'

class Counter extends Component {
  constructor(props) {
    super(props);
    this.incrementAsync = this.incrementAsync.bind(this);
    this.incrementIfOdd = this.incrementIfOdd.bind(this);
  }

  incrementIfOdd() {
    if (this.props.value % 2 !== 0) {
      this.props.onIncrement()
    }
  }

  incrementAsync() {
    setTimeout(this.props.onIncrement, 1000)
  }

  render() {
    const { value, onIncrement, onDecrement } = this.props
    return (
      <p>
        Clicked: {value} times
        {' '}
        <button onClick={onIncrement}>
          +
        </button>
        {' '}
        <button onClick={onDecrement}>
          -
        </button>
        {' '}
        <button onClick={this.incrementIfOdd}>
          Increment if odd
        </button>
        {' '}
        <button onClick={this.incrementAsync}>
          Increment async
        </button>
      </p>
    )
  }
}

Counter.propTypes = {
  value: PropTypes.number.isRequired,
  onIncrement: PropTypes.func.isRequired,
  onDecrement: PropTypes.func.isRequired
}

export default Counter
```