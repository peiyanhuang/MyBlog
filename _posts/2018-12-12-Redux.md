---
layout: post
title:  Redux
date:   2018-12-12 19:58:00 +0800
categories: React
tag: React
---

* content
{:toc}

Redux 能让 Javascript 的状态管理变得更加可预期，Redux 让你以一种新方式思考开发应用，这个方式是：状态从一个初始状态开始，被一系列动作序列改变，这种新方式是通往复杂 Web 应用的捷径。

Redux 是对 Flux 的演进和改变，它们两者也有类似点： Redux 虽然可以使得应用状态改变能更加可预期，但是如果你要改变状态，你还是得启动激活一个动作 Action，没有其他办法直接改变状态，因为含有状态的组件只有一个 `getter` 方法，没有 `setter` 方法用来改变设置状态。

Redux 与 Flux 的主要区别是：

* 在 Redux 中没有 dispatcher，你直接监听者在 Action 动作中，当每次 Action 被激活需要 dispatch 时，使用一个函数称为 reducer 来返回新的应用状态。
* Redux 保留有你所有应用在一个地方，这样避免到处是可变状态，降低副作用。
* 应用状态是不可变的

### 1. Redux 的三大原则

1. 单一数据源 -- 整个应用的 `state` 被储存在一棵 `object tree` 中，并且这个 `object tree` 只存在于唯一一个 `store` 中。至于担心数据对象过于庞大的问题，Redux 提供的工具函数 `combineReducers` 可以化解。
2. 状态(State)是只读的 -- 唯一改变 `state` 的方法就是触发 `action`，`action` 是一个用于描述已发生事件的普通对象。
3. 状态(State)修改均有纯函数完成 -- 通过定义 `reducer` 来修改状态，而每一个 `reducer` 都是纯函数。

### 2. Action、Reducer、Store

Redux 出奇简单，它使用一个函数 `reducer`，只需要两个参数：一个动作 `action` 和下一个状态。`reducer` 函数能够访问当前状态，将动作应用到状态，返回下一个符合业务的状态，这是一种状态模式实现。

Reducer 并不存储状态，只传递状态，返回状态，这使得它看上去也像动作 Action。

#### 2.1 Action

`Action` 是把数据从应用传到 `store` 的有效载荷。它是 `store` 数据的唯一来源。一般来说你会通过 `store.dispatch()` 将 `action` 传到 `store`。

```js
<!-- 定义 Action  -->
const ADD_DATA = "ADD_DATA";

store.dispatch({ type: 'ADD_DATA' });
```

Action 本质上是 JavaScript 普通对象。我们约定，`action` 内必须使用一个字符串类型的 `type` 字段来表示将要执行的动作。多数情况下，`type` 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 `action`。

参照 [Flux 标准 Action](https://github.com/redux-utilities/flux-standard-action) 获取关于如何构造 `action` 的建议。

**Action 创建函数** 就是生成 action 的方法。这样做将使 action 创建函数更容易被移植和测试。

```js
function addTodo(text) {
  return { type: ADD_TODO, text }
}
```

#### 2.2 Reducer

Reducers 指定了应用状态的变化如何响应 `actions` 并发送到 `store` 的。