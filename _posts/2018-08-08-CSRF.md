---
layout: post
title:  CSEF(跨站点请求伪造)
date:   2018-08-03 19:58:00 +0800
categories: 网络安全
tag: 开发者
---

* content
{:toc}

### 1.什么是 CSRF?

wiki 是这么介绍的--跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。

### 2.攻击的过程

1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；
2. 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；
3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；
4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；
5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。

跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了 web 中用户身份验证的一个漏洞：**简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的**。

### 3.CSRF 的防御

#### 3.1 验证码

这个方案要求用户在提交表单时填写一个图片上的随机字符串。但是考虑到用户体验，不能在所有的操作上都加上验证码。因此，验证码只能作为防御 CSFR 的一种辅助手段，而不能作为主要的解决方案。

#### 3.2 Refere

大多数情况下，当浏览器发起一个HTTP请求，其中的 Referer 标识了请求是从哪里发起的。如果 HTTP 头里包含有 Referer 的时候，我们可以区分请求是同域下还是跨站发起的，因为 Referer 里标明了发起请求的 URL。网站也可以通过判断有问题的请求是否是同域下发起的来防御 CSRF 攻击。

不幸的是，通常 Referer 会包含有一些敏感信息，可能会侵犯用户的隐私。比如，Referer 可以显示用户对某个私密网站的搜索和查询。尽管这些内容对私密网站站长来说是好事，因为他们可以通过这些内容来优化搜索引擎排名，但是一些用户还是认为侵犯了他们的隐私。另外，许多组织也很担忧 Referer 可能会将内网的一些机密信息泄露出去。

如果网站选择使用 Referer 来防御 CSRF 攻击的话，那么网站的开发人员就需要决定到底是使用比较宽松还是比较严格的 Referer 验证策略。如果采用宽松的 Referer 验证策略，网站就应该阻止 Referer 值不对的请求。如果请求里面没有 Referer，就接收请求。尽管这个方法用的很普遍，但是它很容易被绕过。因为攻击者可以在 header 里面去掉 Referer。例如，FTP 和数据 URL 发起的请求里面就不包含 Referer。 如果使用严格的 Referer 验证策略，网站还要阻止没有 Referer 的请求。这样做主要是为了防止恶意网站主动隐藏 Referer，但也会带来兼容性问题，比如会误杀一部分合法的请求，因为有些浏览器和网络的设置默认就是不含有 Referer 的。

#### 3.3 Token

由于 CSRF 攻击成功的本质在于攻击者能够获知或猜到请求的所有参数和参数值，所以如果要求在访问敏感数据请求时，要求用户浏览器提供一个攻击者无法伪造的数据作为校验，那么攻击者就无法再执行 CSRF 攻击。这种数据通常是表单中的一个数据项。服务器将其生成并附加在表单中，其内容是一个伪乱数。当客户端通过表单提交请求时，这个伪乱数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪乱数，而通过 CSRF 传来的欺骗性攻击中，攻击者无从事先得知这个伪乱数的值，服务器端就会因为校验 token 的值为空或者错误，拒绝这个可疑请求。

有很多技术可以生成验证 token:

• session 标识符。浏览器的 cookie 存储方式就是为了防止不同域之间互相访问 cookie。一个普遍的做法是直接利用用户的 session 标识符来作为验证 token。服务器在处理每一个请求时，都将用户的 token 与 session 标识符来匹配。如果攻击者能够猜测出用户的 token，那么他就能登录用户的账户。而且这样做有个不好的地方在于，偶尔用户正在浏览的内容会发送给第三方，比如通过电子邮件直接将网页内容上传到浏览器厂商的 bug 跟踪数据库。如果正好这个页面包含有用户的 session 标识符，任何能看到这个页面的人都能模拟用户登陆到网站，直到会话过期。

• 独立 session 随机数。与直接使用用户的 session 标识符不一样的是，当用户第一次登陆网站的时候，服务器可以产生一个随机数并将它存储在用户的 cookie 里面。对于每一个请求，服务器都会将 token 与存储在 cookie 里的值匹配。例如，广泛使用的Trac问题跟踪系统就是用的此技术。但是这个方法不能防御主动的网络攻击，即使是整个web应用都使用的是HTTPS协议。因为攻击者可以使用他自己的CSRF token来覆盖来覆盖这个独立session随机数，进而可以使用一个匹配的token来伪造一个跨站请求。

• 依赖 session 随机数。有一个改进产生随机数的方法是将用户的session标识符与CSRF token建立对应关系后存储在服务端。服务器在处理请求的时候，验证请求中的token是否与session标识符匹配。这个方法有个不好的地方就是服务端必须要维护一个很大的对应关系表（哈希表）。

• session 标识符的HMAC。有一种方法不需要服务端来维护哈希表，就是可以对用户的session token做一个加密后用作CSRF 的token。例如， Ruby on Rails的web程序一般都是使用的这种方法，而且他们是使用session标识符的HMAC来作为CSRF token的。只要所有的网站服务器都共享了HMAC密钥，那么每个服务器都可以验证请求里的CSRF token 是否与session标识符匹配。HMAC的特性能确保即使攻击者知道用户的CSRF token，也不能推断出用户的session标识符。

需要注意一点：就是“并行会话的兼容”。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单 都含有非法的伪随机值。必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。

CSRF 的 Token 仅仅用于对抗 CSRF 攻击，当网站还同时存在 XSS 漏洞是，这个方案就会变得无效，应为 XSS 可以模拟客户端游览器执行任意操作。