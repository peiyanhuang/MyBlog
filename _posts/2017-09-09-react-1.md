---
layout: post
title:  React 学习(1)
date:   2017-09-08 19:58:00 +0800
categories: React
tag: React
---

* content
{:toc}

### dangerouslySetInnerHTML

`dangerouslySetInnerHTML`: 避免 React 转义字符。

### constructor / getInitialState

getInitialState 方法来返回初始化 `this.state` 的值，只在组件装载之前调用一次。

```
var Counter = createReactClass({
  	getInitialState: function() {
    	return {count: this.props.initialCount};
  	},
  	// ...
});
```

如果是使用 ES6 的语法，你也可以在构造函数中初始化状态，比如：

```
class Counter extends Component {
  	constructor(props) {
    	super(props);
    	this.state = { count: props.initialCount };
  	}
  	render() {
    	// ...
  	}
}
```

### 生命周期

*组件挂载*：

`componentWillMount()`: 钩子在组件输出被渲染到 DOM 之前(render 方法执行前)调用。

`componentDidMount()`: 钩子在组件输出被渲染到 DOM 之后(render 方法执行后)调用。

*组件卸载*：

`componentWillUnmount()`: 卸载组件触发。

*更新组件触发*：

这些方法不会在首次 render 组件的周期调用

`componentWillReceiveProps(nextProps)`: 组件的 props 属性可以通过父组件来更改，这时，componentWillReceiveProps 将来被调用。可以在这个方法里更新 state,以触发 render 方法重新渲染组件。

`shouldComponentUpdate(nextProps, nextState)`: 接受需要更新的 props 和 state。可以通过判断让其在需要时更新，不需要时不更新。当返回 false 时，组件不在向下执行生命周期方法。

`componentWillUpdate(nextProps, nextState)`: 接受需要更新的 props 和 state。在 render 前执行，此时不能执行 setState()，

`componentDidUpdate(prveProps, prevState)`: 接受更新前的 props 和 state。在 render 后执行。

(未完)