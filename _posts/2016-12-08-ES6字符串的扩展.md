---
layout: post
title:  ES6 字符串
date:   2016-12-08 20:58:00 +0800
categories: JS
tag: ES6
---

* content
{:toc}

### 1. 字符的Unicode表示法

ASCII字符可以以\x##形式的十六进制表示，例如：

	'\x41'; // 完全等同于 'A'

JavaScript允许采用\uxxxx形式表示一个字符，其中“xxxx”表示字符的码点

	'\u4e2d\u6587'; // '中文'

但是，这种表示法只限于\u0000——\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表达。

ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。

	"\u{20BB7}"
	// "𠮷"

	"\u{41}\u{42}\u{43}"
	// "ABC"

### 2. codePointAt()

JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符。

	var s = "𠮷";
	s.length // 2
	s.charAt(0) // ''
	s.charAt(1) // ''
	s.charCodeAt(0) // 55362
	s.charCodeAt(1) // 57271

对于这种4个字节的字符，JavaScript不能正确处理，字符串长度会误判为2，而且`charAt`方法无法读取整个字符，`charCodeAt`方法只能分别返回前两个字节和后两个字节的值。

ES6提供了`codePointAt`方法，能够正确处理4个字节储存的字符，返回一个字符的码点，`codePointAt`方法返回的是码点的十进制值。

	var s = '𠮷a';
	s.codePointAt(0).toString(16) // "20bb7"
	s.codePointAt(2).toString(16) // "61"

`codePointAt`方法的参数，是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是1，但是必须向`codePointAt`方法传入2。解决这个问题的一个办法是使用for...of循环，因为它会正确识别32位的UTF-16字符。

```
var s = '𠮷a';
for (let ch of s) {
  console.log(ch.codePointAt(0).toString(16));
}
// 20bb7
// 61
```

`codePointAt`方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。

	function is32Bit(c) {
	  return c.codePointAt(0) > 0xFFFF;
	}

### 3. String.fromCodePoint()

ES5提供`String.fromCharCode`方法，用于从码点返回对应字符，但是这个方法不能识别32位的UTF-16字符（Unicode编号大于0xFFFF）。

ES6提供了`String.fromCodePoint`方法，可以识别0xFFFF的字符。在作用上，正好与codePointAt方法相反。

	String.fromCodePoint(0x20BB7);  // "𠮷"

注意，`fromCodePoint`方法定义在String对象上，而`codePointAt`方法定义在字符串的实例对象上。