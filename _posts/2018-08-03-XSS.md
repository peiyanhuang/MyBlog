---
layout: post
title:  XSS 攻击和防御
date:   2018-08-03 19:58:00 +0800
categories: 网络安全
tag: 开发者
---

* content
{:toc}

### 1.什么是 XSS？

跨站脚本攻击，英文全称是 Cross Site Script，本来缩写是 CSS，但是为了和层叠样式表（Cascading Style Sheet，CSS）有所区别，所以在安全领域叫做“XSS”。

XSS 攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是 JavaScript，但实际上也可以包括 Java，VBScript，ActiveX，Flash 或者甚至是普通的 HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和 cookie 等各种内容。

XSS根据效果的不同可以分为以下几类：

**第一种类型**：反射型 XSS。

反射型 XSS 只是简单地把用户输入的数据“反射”给浏览器。也就是说，黑客往往需要诱使用户“点击”一个恶意链接，才能攻击成功。
比如提交的文本内容包含脚本(eg. `<div><script>alert()</script></div>`)

**第二种类型**：存储型XSS。

存储型 XSS 会把用户输入的数据“存储”在服务器端。这种 XSS 具有很强的稳定性。比较常见的一个场景就是，黑客写下一篇包含有恶意 JavaScript 代码的博客文章，文章发表后，所有访问该博客文章的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。黑客把恶意的脚本保存到服务器端，所以这种 XSS 攻击就叫做“存储型XSS”。

**第三种类型**：DOM Based XSS。

实际上，这种类型的 XSS 并非按照“数据是否保存在服务器端”来划分，基于 DOM 的 XSS，通过对具体 DOM 代码进行分析，根据实际情况构造 DOM 节点进行 XSS 跨站脚本攻击。

### 2.XSS Payload

XSS 攻击成功后，攻击者能够对用户当前浏览的页面植入恶意脚本，通过恶意脚本，控制用户的浏览器。这些用以完成各种具体功能的恶意脚本，被称为“XSS PayLoad”。

一个最常见的 XSS Payload，就是通过读取浏览器的 Cookie 对象，从而发起“Cookie劫持”攻击。Cookie 中一般加密保存了当前用户的登录凭证。Cookie 如果丢失，往往意味着用户的登录凭证丢失。换句话说，攻击者可以不通过密码，而直接登录进用户的账户。

XSS 攻击后，攻击者除了可以实施“Cookie劫持”外，还能够通过模拟 GET、POST 请求操作用户的浏览器。这在某些隔离坏境中会非常有用，比如“Cookie劫持”失效时，或者目标用户的网络不能访问互联网的情况。

同时，大部分攻击者是不知道用户的“Old Password”的。为了窃取密码，攻击者可以将 XSS 与“钓鱼”相结合。实现思路很简单，利用 JavaScript 在当前页面上“画出”一个伪造的登录框，当用户在登录框中输入用户名与密码后，其密码将被发送至黑客的服务器上。

在很多时候，攻击者为了获取更大的利益，往往需要准确地收集用户的个人信息。比如，如果知道用户使用的浏览器、操作系统，攻击者就有可能实施一次精准的浏览器内存攻击，最终给用户电脑植入一个木马。XSS 能够帮助攻击者快速达到收集信息的目的。最直接的是通过 XSS 读取浏览器的 UserAgent 对象，但是由于浏览器的 UserAgent 是可以伪造的，所以还可以通过分辨不同浏览器之间的差异准确地判断出浏览器版本。

知道了用户使用的浏览器、操作系统后，进一步可以识别用户安装的软件。在 IE 中，可以通过判断 ActiveX 控件的 classid 是否存在，来推测用户是否安装了该软件（这种方法很早就被用于“挂马攻击”）。浏览器的扩展和插件也能被 XSS Payload 扫描出来。

一般来说，XSS 攻击需要借助第三方软件来完成。比如，客户端安装了 Java 环境，那么 XSS 就可以通过调用 Java Applet 的接口获取客户端的本地 IP 地址。

### 3.XSS 的防御

#### 3.1. HttpOnly

禁止页面的 JavaScript 访问带有 `HttpOnly` 属性的 Cookie。

#### 3.2. 输入检查

同时在客户端和服务端检查用户输入，过滤掉非法输入(永远不要相信客户端的数据)。

1. 针对不同输入类型，对输入做变量类型限制。
2. 对于一些特定输入（生日、邮箱等）具有特定格式的，限制其格式规范。
3. 字符串类型的数据，需要针对（<、>、/、’、”、&）等特殊字符进行实体化转义。

#### 3.3 输出检查

即使在客户端对用户的输入做了过滤、转义，攻击者一样可能，通过截包，转发等手段，修改你的请求包体。最终还是要在数据输出的时候做数据转义。

数据转义啦，不就是对 `<>,’&'` 这些字符做实体化转义吗？如果你认为这么简单，NO NO NO… 因为浏览器解析中html和js编码不一样，以及上下文场景多样，所以对于后台输出的变量，不同的上下文中渲染后端变量，转码不一样。

![image]({{ '/images/web/emcode.webp' | prepend: site.baseurl }})

#### 3.4 防御 DOM Based XSS

会触发 DOM Based XSS 的地方有很多，以下几个方法要小心：

```js
document.write();
document.writeln();

node.innerHTML();
node.outerHTML();

innerHTML.replace();
window.location() // hash、href...
document.cookie
// ...
```

具体的上下文环境具体分析。