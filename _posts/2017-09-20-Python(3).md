---
layout: post
title:  Python 3 面向对象
date:   2017-09-19 19:58:00 +0800
categories: Python
tag: Python
---

* content
{:toc}

### 1.类和实例

```
class Student(object):
	"""docstring for Student"""
	def __init__(self, arg, name):
		super(Student, self).__init__()
		self.arg = arg
		self.name = name

bart = Student('good', 'Bob')
```

在Python中，定义类是通过`class`关键字，`class`后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是`(object)`，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用`object`类，这是所有类最终都会继承的类。变量bart指向的就是一个`Student`的实例.

在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的`__init__`方法，在创建实例的时候，就把name，score等属性绑上去.

注意到`__init__`方法的第一个参数永远是`self`，表示创建的实例本身，因此，在`__init__`方法内部，就可以把各种属性绑定到`self`，因为`self`就指向创建的实例本身。有了`__init__`方法，在创建实例的时候，就不能传入空的参数了，必须传入与`__init__`方法匹配的参数，但`self`不需要传

```
class Student(object):
    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print('%s: %s' % (self.name, self.score))
```

`print_score`这些封装数据的函数是和Student类本身是关联起来的，我们称之为类的方法。

要定义一个方法，除了第一个参数是`self`外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了`self`不用传递，其他参数正常传入.

#### 实例属性和类属性

给实例绑定属性的方法是通过实例变量，或者通过self变量。但是，如果Student类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归Student类所有：

```
class Student(object):
    name = 'Student
```

当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下：

```
>>> class Student(object):
...     name = 'Student'
...
>>> s = Student() # 创建实例s
>>> print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
Student
>>> print(Student.name) # 打印类的name属性
Student
>>> s.name = 'Michael' # 给实例绑定name属性
>>> print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
Michael
>>> print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
Student
>>> del s.name # 如果删除实例的name属性
>>> print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
Student
```

从上面的例子可以看出，不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。

### 2.访问限制

在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。

但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性：

```
bart = Student('Bart Simpson', 98)
print(bart.score)  #98

bart.score = 59
print(bart.score)  #59
```

如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线`__`，在Python中，实例的变量名如果以`__`开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问

```
class Student(object):
    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print('%s: %s' % (self.__name, self.__score))
```

这样就确保了外部代码不能随意修改对象内部的状态, 但是如果外部代码要获取name和score怎么办？可以给Student类增加`get_name`和`get_score`这样的方法; 给Student类增加`set_score`方法, 允许其修改score:

```
class Student(object):
    ...

    def get_name(self):
        return self.__name

    def get_score(self):
        return self.__score

    def set_score(self, score):
        self.__score = score
```

需要注意的是，在Python中，变量名类似`__xxx__`的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用`__name__`、`__score__`这样的变量名。

有些时候，你会看到以一个下划线开头的实例变量名，比如`_name`，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。

双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把`__name`变量改成了`_Student__name`，所以，仍然可以通过`_Student__name`来访问`__name`变量：

```
print(bart._Student__name)  #'Bart Simpson'
```

但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。

最后注意下面的这种错误写法：

```
>>> bart = Student('Bart Simpson', 98)
>>> bart.get_name()
'Bart Simpson'
>>> bart.__name = 'New Name' # 设置__name变量！
>>> bart.__name
'New Name'
```

表面上看，外部代码“成功”地设置了`__name`变量，但实际上这个`__name`变量和`class`内部的`__name`变量不是一个变量！内部的`__name`变量已经被Python解释器自动改成了`_Student__name`，而外部代码给bart新增了一个`__name`变量。

### 3.继承和多态

```
class Animal(object):
    def run(self):
        print('Animal is running...')

class Dog(Animal):
    def run(self):
        print('Dog is running...')

class Cat(Animal):
    pass

dog = Dog()
cat = Cat()

dog.run() #Dog is running...
cat.run() #Animal is running...
```

类Dog、Cat 继承了父类 Animal ，Cat什么都没干，就自动继承了父类的 run() 方法，这就是继承。

当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()(例如Dog)，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态。

### 4.__slots__

```
class Student(object):
	pass
```

给该实例绑定任何属性和方法:

```
s = Student()
s.name = 'Alice' # 动态给实例绑定一个属性
print(s.name) #Alice

from types import MethodType

def set_age(self, age):  # 定义一个函数作为实例方法
	self.age = age

s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
s.set_age(25)
print(s.age) #25
```

但是要注意，给一个实例绑定的方法，对另一个实例是不起作用的。为了给所有实例都绑定方法，可以给class绑定方法：

```
def set_score(self, score):
    self.score = score

Student.set_score = set_score
```
