---
layout: post
title:  Python IO 操作
date:   2017-10-26 19:58:00 +0800
categories: Python
tag: Python
---

* content
{:toc}

### 一. 读写文件

#### 1.读文件

打开文件：

```python
f = open('./logoPage.png', 'rb')
```

`open()`方法用于打开文件。

要读取二进制文件，比如图片、视频等等，用`rb`模式打开文件；一般的文本文件`r`模式打开即可。

像`open()`函数返回的这种有个`read()`方法的对象，在Python中统称为`file-like Object`。除了file外，还可以是内存的字节流，网络流，自定义流等等。`file-like Object`不要求从特定类继承，只要写个`read()`方法就行。

`StringIO`就是在内存中创建的file-like Object，常用作临时缓冲。

如果文件打开成功，接下来，调用`read()`方法可以一次读取文件的全部内容，Python把内容读到内存，用一个`str`对象表示：

```
f.read()
```

调用`read()`会一次性读取文件的全部内容，如果文件过大，内存就爆了，所以，要保险起见，可以反复  
调用`read(size)`方法，每次最多读取`size`个字节的内容。  
调用`readline()`可以每次读取一行内容。  
调用`readlines()`一次读取所有内容并按行返回`list`。

如果文件很小，`read()`一次性读取最方便；如果不能确定文件大小，反复调用`read(size)`比较保险；如果是配置文件，调用`readlines()`最方便：

```
for line in f.readlines():
    print(line.strip()) # 把末尾的'\n'删掉
```

最后一步是调用`close()`方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：

```
f.close()
```

由于文件读写时都有可能产生`IOError`，一旦出错，后面的`f.close()`就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用`try ... finally`来实现：

```
try:
    f = open('/path/to/file', 'r')
    print(f.read())
finally:
    if f:
        f.close()
```

但是每次都这么写实在太繁琐，所以，Python引入了`with`语句来自动帮我们调用`close()`方法：

```
with open('/path/to/file', 'r') as f:
    print(f.read())
```

这和前面的`try ... finally`是一样的，但是代码更佳简洁，并且不必调用`f.close()`方法。

##### 文件编码

要读取非UTF-8编码的文本文件，需要给open()函数传入`encoding`参数，例如，读取GBK编码的文件：

```
f = open('/Users/michael/gbk.txt', 'r', encoding='gbk')
f.read()
```

遇到有些编码不规范的文件，你可能会遇到`UnicodeDecodeError`，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，`open()`函数还接收一个`errors`参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：

	f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore')

#### 2. 写文件

写文件和读文件是一样的，唯一区别是调用`open()`函数时，传入标识符`w`或者`wb`表示写文本文件或写二进制文件：

```
f = open('./read.txt', 'w')
f.write('write something')
f.close()
```

可以反复调用`write()`来写入文件，但是务必要调用`f.close()`来关闭文件。

当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用`close()`方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用`close()`的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险：

```
with open('/Users/michael/test.txt', 'w') as f:
    f.write('Hello, world!')
```

要写入特定编码的文本文件，请给`open()`函数传入`encoding`参数，将字符串自动转换成指定编码。

### 二. StringIO和BytesIO

#### 1. StringIO

很多时候，数据读写不一定是文件，也可以在内存中读写。`StringIO`顾名思义就是在内存中读写str。

要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可：

```
>>> from io import StringIO
>>> f = StringIO()
>>> f.write('hello')
5
>>> f.write('every one is good')
17
>>> f.getvalue()
'every one is good'
```

`getvalue()`方法用于获得写入后的str。

要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：

```
from io import StringIO
f = StringIO('Hello!\nHi!\nGoodbye!')
while True:
    s = f.readline()
    if s == '':
        break
    print(s.strip())
```


#### 2. BytesIO

StringIO操作的只能是str，如果要操作二进制数据，就需要使用`BytesIO`。

BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes：

```
>>> from io import BytesIO
>>> f = BytesIO()
>>> f.write('中文'.encode('utf-8'))
6
>>> print(f.getvalue())
b'\xe4\xb8\xad\xe6\x96\x87'
```

请注意，写入的不是str，而是经过UTF-8编码的bytes。

和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取：

```
>>> from io import BytesIO
>>> f = BytesIO(b'\xe4\xb8\xad\xe6\x96\x87')
>>> f.read()
b'\xe4\xb8\xad\xe6\x96\x87'
```

### 三. 操作文件和目录

如果我们要操作文件、目录，可以在命令行下面输入操作系统提供的各种命令来完成。比如dir、cp等命令。
Python内置的`os`模块也可以直接调用操作系统提供的接口函数。

打开Python交互式命令行：

```
>>> import os
>>> os.name # 操作系统类型
'nt'
```

如果是`posix`，说明系统是`Linux`、`Unix`或`Mac OS X`，如果是`nt`，就是`Windows`系统。

要获取详细的系统信息，可以调用`uname()`(在Windows上不提供)函数。

`os`模块的某些函数是跟操作系统相关的。

#### 环境变量

在操作系统中定义的环境变量，全部保存在os.environ这个变量中，可以直接查看：

	os.environ

要获取某个环境变量的值，可以调用os.environ.get('key')：

```
os.environ.get('x', 'default') #不存在环境变量'x'则返回'default'
```

#### 操作文件和目录

操作文件和目录的函数一部分放在`os`模块中，一部分放在`os.path`模块中。

```
r = os.path.abspath('.') #查看当前目录的绝对路径

newDir = os.path.join(r, 'a')

os.mkdir(newDir) #然后创建一个目录
os.mkdir(newDir) #删掉一个目录
```

1.`os.path.join()`: 把两个路径合成一个

	os.path.join('/Users/michael', 'testdir')

把两个路径合成一个时，不要直接拼字符串，而要通过`os.path.join()`函数，这样可以正确处理不同操作系统的路径分隔符。在Linux/Unix/Mac下，`os.path.join()`返回这样的字符串：

	part-1/part-2

而Windows下会返回这样的字符串：

	part-1\part-2

2.`os.path.split()`: 拆分路径

可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名:

```
>>> os.path.split('/Users/michael/testdir/file.txt')
('/Users/michael/testdir', 'file.txt')
```

3.`os.path.splitext()`可以直接让你得到文件扩展名：

```
>>> os.path.splitext('/path/to/file.txt')
('/path/to/file', '.txt')
```

这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。

4.`rename()`: 对文件重命名

	os.rename('test.txt', 'test.py')

5.`remove()`:删掉文件

	os.remove('test.py')

6.复制文件

但是复制文件的函数居然在os模块中不存在！原因是复制文件并非由操作系统提供的系统调用。理论上讲，我们通过上一节的读写文件可以完成文件复制，只不过要多写很多代码。

幸运的是[shutil](https://docs.python.org/3.6/library/shutil.html)模块提供了`copyfile()`的函数，你还可以在`shutil`模块中找到很多实用函数，它们可以看做是`os`模块的补充。

7.最后看看如何利用Python的特性来过滤文件。比如我们要列出当前目录下的所有目录，只需要一行代码：

```
>>> [x for x in os.listdir('.') if os.path.isdir(x)]
['.lein', '.local', '.m2', '.npm', '.ssh', '.Trash', '.vim', 'Applications', 'Desktop', ...]
```

要列出所有的.py文件，也只需一行代码：

```
>>> [x for x in os.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1]=='.py']
['apis.py', 'config.py', 'models.py', 'pymonitor.py', 'test_db.py', 'urls.py', 'wsgiapp.py']
```