---
layout: post
title:  chrome插件开发
date:   2020-08-19 19:00:00 +0800
categories: 开发者
tag: 开发者
---

* content
{:toc}

### 1.什么是 Chrome 扩展？

扩展程序允许您为 Chrome 浏览器增加功能，而不需要深入研究代码。您可以使用您在网页开发中已经很熟悉的核心技术（HTML、CSS 与 JavaScript）为 Chrome 浏览器创建新的扩展程序。

### 2.如何创建一个扩展

首先创建清单文件 `manifest.json` 文件:

```json
{
	// 清单文件的版本，这个必须写，而且必须是2
	"manifest_version": 2,
	// 插件的名称
	"name": "demo",
	// 插件的版本
	"version": "1.0.0",
	// 插件描述
	"description": "简单的Chrome扩展demo",
	// 图标，一般偷懒全部用一个尺寸的也没问题
	"icons": {
		"16": "img/icon.png",
		"48": "img/icon.png",
		"128": "img/icon.png"
	},
	// 会一直常驻的后台JS或后台页面
	"background": {
		// 2种指定方式，如果指定JS，那么会自动生成一个背景页
		//"scripts": ["js/background.js"]
		"page": "background.html"
	},
	// 浏览器右上角图标设置，browser_action、page_action
	"browser_action": {
		"default_icon": "img/icon.png",
		// 图标悬停时的标题，可选
		"default_title": "这是一个示例Chrome插件",
		"default_popup": "popup.html"
	},
	// 当某些特定页面打开才显示的图标
	/*"page_action":
	{
		"default_icon": "img/icon.png",
		"default_title": "我是pageAction",
		"default_popup": "popup.html"
	},*/
	// 权限申请
	"permissions": [
		"contextMenus", // 右键菜单
		"tabs", // 标签
		"notifications", // 通知
		"webRequest", // web请求
		"storage", // 插件本地存储
		"http://*/*", // 可以通过executeScript或者insertCSS访问的网站
		"https://*/*" // 可以通过executeScript或者insertCSS访问的网站
	],
	// 需要直接注入页面的JS
	"content_scripts": [
		{
			//"matches": ["http://*/*", "https://*/*"],
			// "<all_urls>" 表示匹配所有地址
			"matches": ["<all_urls>"],
			// 多个JS按顺序注入
			"js": ["js/jquery-1.8.3.js", "js/content-script.js"],
			// JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式
			"css": ["css/custom.css"],
			// 代码注入的时间，可选值： "document_start", "document_end", or "document_idle"，最后一个表示页面空闲时，默认document_idle
			"run_at": "document_start"
		},
		// content-script可以配置多个规则
		{
			"matches": ["*://*/*.png", "*://*/*.jpg", "*://*/*.gif", "*://*/*.bmp"],
			"js": ["js/show-image-content-size.js"]
		}
	],
	// 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的
	"web_accessible_resources": ["js/inject.js"],
	// 插件主页，这个很重要，不要浪费了这个免费广告位
	"homepage_url": "https://www.baidu.com",
	// 覆盖浏览器默认页面
	"chrome_url_overrides": {
		// 覆盖浏览器默认的新标签页
		"newtab": "newtab.html"
	},
	// Chrome40以前的插件配置页写法
	"options_page": "options.html",
	// Chrome40以后的插件配置页写法，如果2个都写，新版Chrome只认后面这一个
	"options_ui": {
		"page": "options.html",
		// 添加一些默认的样式，推荐使用
		"chrome_style": true
	},
	// 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字
	"omnibox": { "keyword" : "go" },
	// 默认语言
	"default_locale": "zh_CN",
	// devtools页面入口，注意只能指向一个HTML文件，不能是JS文件
	"devtools_page": "devtools.html"
}
```

#### content-scripts

所谓 `content-scripts`，其实就是 Chrome 插件中向页面注入脚本的一种形式（虽然名为script，其实还可以包括css的），借助 `content-scripts` 我们可以实现通过配置的方式轻松向指定页面注入 JS 和 CSS。

特别注意，如果没有主动指定run_at为document_start（默认为document_idle），下面这种代码是不会生效的：

```js
document.addEventListener('DOMContentLoaded', () => {
	console.log('我被执行了！');
});
```

`content-scripts` 和原始页面共享 DOM，但是不共享JS，如要访问页面JS（例如某个JS变量），只能通过 `injected js` 来实现:

```js
// js/content_script.js
injectCustomJs('content_script/inject.js');

function injectCustomJs (jsPath) {
  const temp = document.createElement('script');
  temp.setAttribute('type', 'text/javascript');
  temp.setAttribute('src', chrome.extension.getURL(jsPath));
  document.body.appendChild(temp);
}

// js/inject.js
(function () {
	window.networkPlusXhr = function () {
		// ...
  }
})();
```

#### background

它是一个常驻的页面，它的生命周期是插件中所有类型页面中最长的，它随着浏览器的打开而打开，随着浏览器的关闭而关闭，所以通常把需要一直运行的、启动就运行的、全局的代码放在background里面。

例如监听扩展的生命周期：

```js
chrome.runtime.onInstalled.addListener(function() {
	// 添加右键菜单
  chrome.contextMenus.create({
    type: "normal",
    id: "1",
    title: "Sample Context Menu",
    onclick: () => {
      console.log('contextMenus')
    }
  });
});
```

#### popup

`popup` 是点击 `browser_action` 或者 `page_action` 图标时打开的一个小窗口网页，焦点离开网页就立即关闭，一般用来做一些临时性的交互。`page-action`指的是只有当某些特定页面打开才显示的图标，而 `browser-action`始终都显示。

```js
// manifest.json
{
	"page_action":
	{
		"default_icon": "img/icon.png",
		"default_title": "我是pageAction",
		"default_popup": "popup.html"
	},
	"permissions": [
		"declarativeContent"
	]
}

// background.js
chrome.runtime.onInstalled.addListener(function () {
	chrome.declarativeContent.onPageChanged.removeRules(undefined, function () {
		chrome.declarativeContent.onPageChanged.addRules([
			{
				conditions: [
					// 只有打开百度才显示pageAction
					new chrome.declarativeContent.PageStateMatcher({
						pageUrl: {urlContains: 'baidu.com'}
					})
				],
				actions: [new chrome.declarativeContent.ShowPageAction()]
			}
		]);
	});
});
```

#### devtools(开发者工具)

- 自定义一个和多个和 Elements、Console、Sources 等同级别的面板；
- 自定义侧边栏(sidebar)，目前只能自定义Elements面板的侧边栏；

每打开一个开发者工具窗口，都会创建 `devtools` 页面的实例，F12 窗口关闭，页面也随着关闭，所以 `devtools` 页面的生命周期和 `devtools` 窗口是一致的。

```js
// 几个参数依次为：panel标题、图标（其实设置了也没地方显示）、要加载的页面、加载成功后的回调
chrome.devtools.panels.create('wePlugin', 'img/panel.png', 'devtools_page.html', (panel) => {
  console.log('自定义面板创建成功！', panel) // 注意这个log一般看不到
})

// 创建自定义侧边栏
chrome.devtools.panels.elements.createSidebarPane('Images', (sidebar) => {
  // sidebar.setPage('../sidebar.html'); // 指定加载某个页面
  sidebar.setExpression('document.querySelectorAll("img")', 'All Images') // 通过表达式来指定
  // sidebar.setObject({aaa: 111, bbb: 'Hello World!'}); // 直接设置显示某个对象
})
```

#### 通信

#### popup 和 background

popup可以直接调用background中的JS方法，也可以直接访问background的DOM：

```js
// background.js
function test() {
	alert('我是background！');
}

// popup.js
var bg = chrome.extension.getBackgroundPage();
bg.test(); // 访问bg的函数
alert(bg.document.body.innerHTML); // 访问bg的DOM
```

至于background访问popup如下（前提是popup已经打开）：

```js
var views = chrome.extension.getViews({type:'popup'});
if(views.length > 0) {
	console.log(views[0].location.href);
}
```

#### popup、background、devtools 与 content_script 通信

popup、background、devtools 向 content_script 发送

```js
// popup、background、devtools
function sendMessageToContentScript(message, callback) {
	chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
		chrome.tabs.sendMessage(tabs[0].id, message, function(response) {
			if(callback) callback(response);
		});
	});
}
sendMessageToContentScript({cmd:'test', value:'你好！'}, function(response) {
	console.log('来自content的回复：'+response);
});

// content_script
chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
	if(request.cmd == 'test') alert(request.value);
	sendResponse('我收到了你的消息！');
});
```

相反

```js
// content_script
chrome.runtime.sendMessage({greeting: '你好！'}, function(response) {
	console.log('收到来自后台的回复：' + response);
});

// popup、background、devtools
chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
	console.log('收到来自content-script的消息：');
	sendResponse('我是后台，我已收到你的消息：');
});
```

如果 `background` 和 `popup` 同时监听，那么它们都可以同时收到消息，但是只有一个可以 `sendResponse`，一个先发送了，那么另外一个再发送就无效。

#### devtools 与 background

```js
// 发送
chrome.runtime.sendMessage({greeting: '你好！'}, function(response) {
	console.log('收到回复：' + response);
});

// 接受
chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
	console.log(request);
	sendResponse('我已收到你的消息：');
});
```

#### inject 和 content_script

可以通过 `window.postMessage` 和 `window.addEventListener` 来实现二者消息通讯；

```js
// 发送信息
window.postMessage({
	type: 'common',
	value: 100
}, '*');

// 接受消息
window.addEventListener("message", function(e) {
	console.log(e.data);
}, false);
```

#### devtools 与 inject

有两种方式：

1. 通过 `contnt_script` 中转；
2. 使用 `chrome.devtools.inspectedWindow.eval()`;

```js
const functionStr = `networkPlusXhr('${editUrl}','${editMethod}','${editRequestHeaders}','${editRequestBody}')`
const escapedFunctionStr = functionStr.replace(/\\"/g, '\\\\\\"')
chrome.devtools.inspectedWindow.eval(escapedFunctionStr, (result, isException) => {
  console.log(isException)
})
```

#### 本地存储

本地存储建议用 `chrome.storage` 而不是普通的 `localStorage`，最重要的2点区别是：

- `chrome.storage` 是针对插件全局的，即使你在 `background` 中保存的数据，在 `content_script` 也能获取到；
- `chrome.storage.sync` 可以跟随当前登录用户自动同步，这台电脑修改的设置会自动同步到其它电脑，很方便，如果没有登录或者未联网则先保存到本地，等登录了再同步至网络；